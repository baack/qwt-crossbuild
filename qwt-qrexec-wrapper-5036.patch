From 89212095dbf2963065986aa58b299edca5c88ffb Mon Sep 17 00:00:00 2001
From: Tom Carroll <Thomas.Carroll@pnnl.gov>
Date: Fri, 17 May 2019 20:32:42 -0700
Subject: [PATCH 1/2] Not recognizing EOF may deadlock qrexec-wrapper.

Condition caused open-in-vm (and other services) to deadlock. Fix
addresses two issues:
- Recongize ERROR_BROKEN_PIPE as EOF condition when reading pipes,
- Transmit zero-length message on vchan to signal EOF to remote.
---
 src/qrexec-wrapper/qrexec-wrapper.c | 94 ++++++++++++++---------------
 1 file changed, 47 insertions(+), 47 deletions(-)

diff --git a/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c b/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
index b1c381b..73badc1 100644
--- a/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
+++ b/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
@@ -586,14 +586,23 @@ DWORD HandleDataMessage(
     return ERROR_SUCCESS;
 }
 
-DWORD WINAPI StdoutThread(
-    PVOID param
+/**
+ * @brief Read data from child's pipe, send to vchan
+ */
+static DWORD handle_child_output(
+    _Inout_ PCHILD_STATE child,
+    _In_    PIPE_TYPE pipe_type
     )
 {
-    DWORD transferred;
-    PCHILD_STATE child = param;
-    PBYTE buffer = malloc(MAX_DATA_CHUNK);
+    PPIPE_DATA pipe;
+    PBYTE buffer;
+    DWORD eof;
 
+    assert(child);
+
+    pipe = pipe_type == PTYPE_STDOUT ? &child->Stdout : &child->Stderr;
+
+    buffer = malloc(MAX_DATA_CHUNK);
     if (!buffer)
     {
         LogError("no memory");
@@ -602,70 +611,61 @@ DWORD WINAPI StdoutThread(
 
     LogVerbose("start");
 
-    // read from the child's stdout pipe, send to data vchan
-    while (TRUE)
+    eof = FALSE;
+    while (!eof)
     {
+        DWORD nread, ok;
+
         LogVerbose("reading...");
-        if (!ReadFile(child->Stdout.ReadEndpoint, buffer, MAX_DATA_CHUNK, &transferred, NULL)) // this can block
+        ok = ReadFile(pipe->ReadEndpoint, buffer, MAX_DATA_CHUNK,
+                      &nread, NULL); // this can block
+        // nread is set to zero on entry
+        //
+        // EOF is signaled by either:
+        // - ok and nread == 0
+        // - !ok and GetLastError() == ERROR_BROKEN_PIPE.
+        //
+        // ReadFile of an anonymous pipe returns FALSE and GetLastError
+        // returns ERROR_BROKE_PIPE when the corresponding write handle 
+        // has been closed.
+        if (!ok && GetLastError() != ERROR_BROKEN_PIPE)
         {
-            perror("ReadFile(stdout)");
-            break;
+            perror("ReadFile");
+            goto cleanup;
         }
-
-        LogVerbose("read %lu 0x%lx", transferred, transferred);
-        if (!VchanSendData(child, buffer, transferred, PTYPE_STDOUT))
+        eof = nread == 0;
+        // EOF is signaled to the remote via zero count
+        LogVerbose("read %lu 0x%lx", nread, nread);
+        if (!VchanSendData(child, buffer, nread, pipe_type))
         {
             LogError("VchanSendData failed");
-            break;
+            goto cleanup;
         }
     }
 
 cleanup:
-    ClosePipe(&child->Stdout);
+    ClosePipe(pipe);
     LogVerbose("exiting");
     free(buffer);
     return 1;
 }
 
-DWORD WINAPI StderrThread(
+DWORD WINAPI StdoutThread(
     PVOID param
     )
 {
-    DWORD transferred;
     PCHILD_STATE child = param;
-    PBYTE buffer = malloc(MAX_DATA_CHUNK);
-
-    if (!buffer)
-    {
-        LogError("no memory");
-        goto cleanup;
-    }
 
-    LogVerbose("start");
-
-    // read from the child's stderr pipe, send to data vchan
-    while (TRUE)
-    {
-        LogVerbose("reading...");
-        if (!ReadFile(child->Stderr.ReadEndpoint, buffer, MAX_DATA_CHUNK, &transferred, NULL)) // this can block
-        {
-            perror("ReadFile(stderr)");
-            break;
-        }
+    return handle_child_output(child, PTYPE_STDOUT);
+}
 
-        LogVerbose("read %lu 0x%lx", transferred, transferred);
-        if (!VchanSendData(child, buffer, transferred, PTYPE_STDERR))
-        {
-            LogError("VchanSendData failed");
-            break;
-        }
-    }
+DWORD WINAPI StderrThread(
+    PVOID param
+    )
+{
+    PCHILD_STATE child = param;
 
-cleanup:
-    ClosePipe(&child->Stderr);
-    LogVerbose("exiting");
-    free(buffer);
-    return 1;
+    return handle_child_output(child, PTYPE_STDERR);
 }
 
 static void XifLogger(int level, const char *function, const WCHAR *format, va_list args)

From 8745c58eab0ad7892d91c25762cf65f8ad887543 Mon Sep 17 00:00:00 2001
From: Tom Carroll <Thomas.Carroll@pnnl.gov>
Date: Fri, 17 May 2019 22:11:14 -0700
Subject: [PATCH 2/2] Signal error by sending EOF

Send zero-length message on vchan if error is encountered during
pipe read.
---
 src/qrexec-wrapper/qrexec-wrapper.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c b/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
index 73badc1..0870b6b 100644
--- a/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
+++ b/qubes-core-agent-windows-mingw/src/qrexec-wrapper/qrexec-wrapper.c
@@ -619,7 +619,6 @@ static DWORD handle_child_output(
         LogVerbose("reading...");
         ok = ReadFile(pipe->ReadEndpoint, buffer, MAX_DATA_CHUNK,
                       &nread, NULL); // this can block
-        // nread is set to zero on entry
         //
         // EOF is signaled by either:
         // - ok and nread == 0
@@ -630,8 +629,9 @@ static DWORD handle_child_output(
         // has been closed.
         if (!ok && GetLastError() != ERROR_BROKEN_PIPE)
         {
+            // if !ok, then nread == 0
+            // Signal error condition by sending EOF
             perror("ReadFile");
-            goto cleanup;
         }
         eof = nread == 0;
         // EOF is signaled to the remote via zero count
